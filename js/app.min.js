// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

var _paramValueEverywhere = ['depth', 'count', 'forbidden_uris[]', 'filter'];
var _collections = ['addresses', 'commercial_modes', 'companies', 'coord', 'coverage', 'disruptions', 'lines', 'networks', 'places',
               'poi_types', 'pois', 'physical_modes', 'routes', 'stop_areas', 'stop_points', 'vehicle_journeys'].sort();
var _additionalFeatures = ['departures', 'journeys', 'places_nearby', 'pt_objects', 'route_schedules', 'stop_schedules',
                            'arrivals', 'isochrones'];
var _paramJourneyCommon = ['from', 'to', 'datetime','traveler_type', 'data_freshness',
            'first_section_mode[]', 'last_section_mode[]'].concat(_paramValueEverywhere).sort();

// ParamKey
var _depArrParams = ['from_datetime', 'duration', 'data_freshness'].concat(_paramValueEverywhere).sort();
var _schedulesParams = ['from_datetime', 'duration', 'items_per_schedule', 'data_freshness'].concat(_paramValueEverywhere).sort();
var _placesParams = ['q', 'type[]', 'admin_uri[]'].concat(_paramValueEverywhere).sort();

// ParamValue
var _fallbackMode = ['walking', 'car', 'bike', 'bss'].sort();

var autocomplete = {
    autocompleteTree: {
        pathKey: {
            empty : ['coverage', 'places', 'coord'],
            all : _collections,
        },
        features: {
            all: _collections.concat(_additionalFeatures).sort(),
        },
        paramKey: {
            arrivals: _depArrParams,
            coord: _paramValueEverywhere,
            coverage: _paramValueEverywhere,
            departures: _depArrParams,
            journeys: ['datetime_represents'].concat(_paramJourneyCommon).sort(),
            isochrones: [ 'max_duration', 'min_duration', 'boundary_duration[]'].concat(_paramJourneyCommon).sort(),
            lines: _paramValueEverywhere,
            places_nearby: _placesParams.sort(),
            places: _placesParams,
            pois: ['distance'].concat(_paramValueEverywhere).sort(),
            pt_objects: ['q', 'type[]'].concat(_paramValueEverywhere),
            stop_areas: _paramValueEverywhere,
            stop_points: _paramValueEverywhere,
            routes: _paramValueEverywhere,
            route_schedules: _schedulesParams,
            stop_schedules: _schedulesParams,
            empty: _paramValueEverywhere,
        },
        paramValue : {
            traveler_type : ['luggage', 'standard', 'fast_walker', 'slow_walker'].sort(),
            datetime_represents : ['arrival', 'departure'].sort(),
            'first_section_mode[]': _fallbackMode,
            'last_section_mode[]': _fallbackMode,
        }
    },
    apiAutocomplete: function() {
        var input = $("#api input.api");
        var apis = [];
        for (var elt in window.localStorage) {
            if (elt.indexOf(apiStoragePrefix) === 0 ) {
                apis.push({value: elt.slice(apiStoragePrefix.length), desc: elt} );
            }
        }
        autocomplete._customAutocompleteHelper(input, apis,
            {
                select: function (event, ui) {
                    $(input).val(ui.item.value);
                    $("#token input.token").val(window.localStorage.getItem(ui.item.desc));
                }
            });
    },
    valueAutoComplete: function (input, key) {
        if (isDatetimeType(key)) {
            autocomplete._makeDatetime(input);
        } else if (key in this.autocompleteTree.paramValue){
            autocomplete._customAutocompleteHelper(input, this.autocompleteTree.paramValue[key]);
        } else if (this.staticAutocompleteTypes.indexOf(key) > -1) {
            this.staticAutocomplete(input, key);
        } else if (this.dynamicAutocompleteTypes.indexOf(key) > -1) {
            this.dynamicAutocomplete(input, key);
        }
    },
    addKeyAutocomplete: function(input, type) {
        var source;
        if (type === 'pathKey' && ! $('#pathFrame').find('.value').length) {
            source = this.autocompleteTree[type].empty;
        } else if (type === 'paramKey'){
            var feature = $('#featureInput').val();
            source = this.autocompleteTree[type][feature] || this.autocompleteTree[type].empty;
        } else {
            source = this.autocompleteTree[type].all;
        }
        source = source || [];
        autocomplete._customAutocompleteHelper(input, source,
            {
                select: function(event, ui) { $(input).val(ui.item.value).change(); }
            });
    },
    staticAutocompleteTypes: ['coverage',
        'physical_modes',
        'poi_types',
    ],
    staticAutocomplete : function (input, staticType){
        var api = $('#api input.api').attr('value');
        var token = $('#token input.token').val();
        var cov = getCoverage();
        var request = '';
        if (staticType === 'coverage') {
            request =  api +  '/coverage/';
        } else {
            request =  api +  '/coverage/' + cov + '/' + staticType;
        }
        $.ajax({
            headers: manage_token(token),
            dataType: 'json',
            url: request,
            success: function(data) {
                var res = [];
                staticType = (staticType==='coverage') ? 'regions' :  staticType;
                data[staticType].forEach(function(elt) {
                    var s = summary.run(new Context(), getType(staticType), elt);
                    res.push({ value: elt.id, label: s.textContent, desc: s });
                });
                res = res.sort(function(a, b) {
                    if (a.label < b.label) { return -1; }
                    if (a.label > b.label) { return 1; }
                    return 0;
                });
                $(input).autocomplete({
                    close: function() { updateUrl($(input)[0]); },
                    focus: function() { updateUrl($(input)[0]); },
                    source: res,
                    minLength: 0,
                    scroll: true,
                    delay: 500
                }).focus(function() {
                    $(input).autocomplete('search', '');
                }).autocomplete('instance')._renderItem = function(ul, item) {
                    return $('<li>').append(item.desc).appendTo(ul);
                };
                if ($(input).is(':focus')) {
                    $(input).autocomplete('search', '');
                }
            },
            error: function(data, status, xhr) {
                notifyOnError(data, 'Autocomplete');
            }
        });
    },
    dynamicAutocompleteTypes: [
        'addresses',
        'administrative_regions',
        'commercial_modes',
        'coord',
        'forbidden_uris[]',
        'lines',
        'networks',
        'places',
        'pois',
        'routes',
        'stop_areas',
        'stop_points',
        'from',
        'to',
    ],
    dynamicAutocomplete: function (elt, dynamicType) {
        var formatPtReq = function (v){
            return sprintf('pt_objects/?type[]=%s&q=', v);
        };
        var formatPlacesReq = function (v){
            return sprintf('places/?type[]=%s&q=', v);
        };
        var dynamicTypeRequest = {
            addresses: formatPlacesReq('address'),
            administrative_regions: formatPlacesReq('administrative_region'),
            commercial_modes: formatPtReq('commercial_mode'),
            coord: formatPlacesReq('address'),
            'forbidden_uris[]': 'pt_objects/?q=',
            lines: formatPtReq('line'),
            networks: formatPtReq('network'),
            places: 'places/?&q=',
            pois: formatPlacesReq('poi'),
            routes: formatPtReq('route'),
            stop_areas: formatPtReq('stop_area'),
            stop_points: formatPlacesReq('stop_point'),
            from: 'places/?&q=',
            to: 'places/?&q=',
        };
        var httpReq = dynamicTypeRequest[dynamicType];
        if (! httpReq) {
            return;
        }
        $(elt).autocomplete({
            delay: 200,
            close: function() { updateUrl($(elt)[0]); },
            focus: function() { updateUrl($(elt)[0]); },
            source: function (request, response) {
                var token = $('#token input.token').val();
                var url = $('#api input.api').val();
                var cov = getCoverage();
                // cov can be null in case where coverage is not specifeid
                cov = cov ? ('coverage/' + cov) : '';
                $.ajax({
                    url: sprintf('%s/%s/%s%s', url, cov, httpReq, encodeURIComponent(request.term)),
                    headers: manage_token(token),
                    success: function (data) {
                        var res = [];
                        // TODO: use summary
                        var search = null;
                        var type = null;
                        if ('places' in data) {
                            search = data.places;
                            type = 'place';
                        } else if ('pt_objects' in data) {
                            search = data.pt_objects;
                            type = 'pt_object';
                        }
                        if (search) {
                            search.forEach(function(s) {
                                var sum = summary.run(new Context(), type, s);
                                res.push({ value: s.id, label: sum });
                            });
                        }
                        response(res);
                    },
                    error: function(data, status, xhr) {
                        response([]);
                        notifyOnError(data, 'Autocomplete');
                    }
                });
            }
        }).autocomplete('instance')._renderItem = function(ul, item) {
            return $('<li>').append(item.label).appendTo(ul);
        };
    },
    _customAutocompleteHelper: function(input, source, customOptions) {
        var options = {
            close: function() { updateUrl($(input)[0]); },
            focus: function() { updateUrl($(input)[0]); },
            source: source,
            minLength: 0,
            scroll: true,
            delay: 500
        };
        if (customOptions) { $.extend(true, options, customOptions); }
        $(input).autocomplete(options).focus(function() {
            $(this).autocomplete('search', '');
        });
    },
    _makeDatetime: function(elt) {
        $(elt).datetimepicker({
            dateFormat: 'yymmdd',
            timeFormat: 'HHmmss',
            timeInput: true,
            separator: 'T',
            controlType: 'select',
            oneLine: true,
        });
    },
}

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

var extended = {};

// the object that contains the function to make the extended views
extended.make = {}

extended.make.response = function(context, json) {
    var result = $('<div class="list"/>');

    if ('full_response' in json) {
        result.append(render(context, json.full_response, 'response', 'full_response'));
    }

    if ('links' in json) {
        result.append(render(context, json.links, 'links', 'links'));
    }

    var key = responseCollectionName(json);
    var objs = key ? json[key] : [];
    var type = getType(key);
    if (type) {
        objs.forEach(function(obj, i) {
            result.append(render(context, obj, type, key, i));
        });
    }

    if ('warnings' in json) {
        json.warnings.forEach(function(warning, i) {
            result.append(render(context, warning, 'warning', 'warnings', i));
        });
    }
    return result;
}

extended.make.journey = function(context, json) {
    if (! ('sections' in json)) { return extended.noExtendedMessage; }
    var result = $('<div class="list"/>');
    if ('tags' in json && json.tags.length > 0) {
        result.append(render(context, json.tags, 'tags', 'tags'));
    }
    json.sections.forEach(function(section, i) {
        result.append(render(context, section, 'section', 'sections', i));
    });
    return result;
}

extended.make.section = function(context, json) {
    if (! ('stop_date_times' in json)) { return extended.noExtendedMessage; }
    var result = $('<div class="list"/>');
    json.stop_date_times.forEach(function(stop_date_time, i) {
        result.append(render(context, stop_date_time, 'stop_date_time', 'stop_date_times', i));
    });
    return result;
}

extended.make.stop_schedule = function(context, json) {
    var result = $('<div class="list"/>');
    json.date_times.forEach(function(date_time, i) {
        result.append(render(context, date_time, 'date_time', 'date_times', i));
    });
    return result;
}

extended.make.route_schedule = function(context, json) {
    var result = $('<div class="table"/>');
    var table = $('<table/>');
    // Add the data rows
    json.table.rows.forEach(function(route_schedule, i) {
        var row = $('<tr/>');
        var cellName = $('<td />').addClass('stop-point');
        cellName.html(summary.run(context, 'stop_point', route_schedule.stop_point));
        row.append(cellName);
        route_schedule.date_times.forEach(function(route_schedule, i) {
            var cellValue = $('<td />').addClass('time');
            cellValue.html(summary.formatTime(route_schedule.date_time));
            row.append(cellValue);
        });
        table.append(row);
    });
    result.append(table);
    return result;
}

// add your extended view by addind:
//   extended.make.{type} = function(context, json) { ... }

extended.defaultExtended = function(context, type, json) {
    var noExt = extended.noExtendedMessage;
    if (! (json instanceof Object)) {
        return noExt;
    }
    var empty = true;
    var result = $('<div class="list"/>');
    for (var key in json) {
        if (! (getType(key) in context.links)) { continue; }
        empty = false;
        if ($.isArray(json[key])) {
            json[key].forEach(function(obj, i) {
                result.append(render(context, obj, getType(key), key, i));
            });
        } else {
            result.append(render(context, json[key], getType(key), key));
        }
    }
    if (empty) {
        return noExt;
    } else {
        return result;
    }
}

extended.noExtendedMessage = 'No extended view yet!';

extended.hasExtended = function(context, type, json) {
    return extended.run(context, type, json) !== extended.noExtendedMessage;
}

// main method
extended.run = function(context, type, json) {
    try {
        if (type in this.make) { return this.make[type](context, json); }
        return extended.defaultExtended(context, type, json);
    } catch (e) {
        console.log(sprintf('extended(%s) thows an exception:', type));
        console.log(e);
        return extended.noExtendedMessage;
    }
}

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

var map = {
    DrawSectionOption: {
        DRAWSTART: 2, // 10
        DRAWEND: 1, // 01
        DRAWBOTH: 3, // 11
        DRAWNEITHER: 0 // 00
    },
    _should_draw_section_start: function(option) {
        return option & 2;
    },
    _should_draw_section_end: function(option) {
        return option & 1;
    },
    STARTTEXT : 'Start',
    ENDTEXT : 'End',
    makeFeatures: {
        region: function(context, json) {
            if (json.shape) {
                var geoJsonShape = wkt2geojson(json.shape);
                return map._makePolygon(context, 'region', geoJsonShape, json, {color : '008ACA'});
            }
            return [];
        },
        section: function(context, json, draw_section_option) {
            var color = json.display_informations;
            switch (json.type) {
            case 'street_network':
                switch (json.mode) {
                case 'bike': color = map.bikeColor; break;
                case 'car': color = map.carColor; break;
                case 'walking': color = map.walkingColor; break;
                }
                break;
            case 'transfer':
                switch (json.transfer_type) {
                case 'guaranteed': color = map.carColor; break;
                case 'extension': color = map.bikeColor; break;
                case 'walking': color = map.walkingColor; break;
                }
                break;
            }
            if (draw_section_option === undefined) {
                draw_section_option = map.DrawSectionOption.DRAWBOTH;
            }
            return map._makeString(context, 'section', json, color)
                .concat(map._makeStopTimesMarker(context, json, color, draw_section_option));
        },
        line: function(context, json) {
            return map._makeString(context, 'line', json, json);
        },
        journey: function(context, json) {
            if (! ('sections' in json)) { return []; }
            var bind = function(s, i, array) {
                var draw_section_option = map.DrawSectionOption.DRAWNEITHER;
                if ( i === 0) { draw_section_option |= map.DrawSectionOption.DRAWSTART; }
                if ( i === (array.length -1) ) { draw_section_option |= map.DrawSectionOption.DRAWEND; }
                return map.makeFeatures.section(context, s, draw_section_option);
            };
            return flatMap(json.sections, bind);
        },
        isochrone: function(context, json) {
            if (! ('geojson' in json)) { return []; }
            var color = context.min_duration_color[json.min_duration];
            return map._makePolygon(context, 'isochrone', json.geojson, json, color);
        },
        address: function(context, json) {
            return map._makeMarker(context, 'address', json);
        },
        administrative_region: function(context, json) {
            return map._makeMarker('administrative_region', json);
        },
        stop_area: function(context, json) {
            return map._makeMarker(context, 'stop_area', json);
        },
        stop_point: function(context, json) {
            return map._makeMarker(context, 'stop_point', json);
        },
        place: function(context, json) {
            return map._makeMarker(context, 'place', json);
        },
        poi: function(context, json) {
            return map._makeMarker(context, 'poi', json);
        },
        response: function(context, json) {
            var key = responseCollectionName(json);
            if (key === null) {
                return [];
            }
            var type = getType(key);
            if (!(type in map.makeFeatures)) {
                return [];
            }
            var bind = function(s) {
                return map.makeFeatures[type](context, s);
            };
            return flatMap(json[key], bind);
        }
    },

    hasMap: function(context, type, json) {
        return map.getFeatures(context, type, json).length !== 0;
    },

    getFeatures: function(context, type, json) {
        if (! (map.makeFeatures[type] instanceof Function)) { return []; }
        try {
            return map.makeFeatures[type](context, json);
        } catch (e) {
            console.log(sprintf('map.makeFeatures[%s] thows an exception:', type));
            console.log(e);
            return [];
        }
    },

    run: function(context, type, json) {
        var div = $('<div/>');
        // setting for default path of images used by leaflet
        L.Icon.Default.imagePath='lib/img/leaflet/dist/images';
        var features = [];
        if ((features = map.getFeatures(context, type, json)).length) {
            div.addClass('leaflet');
            var m = L.map(div.get(0)).setView([48.843693, 2.373303], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.se/hydda/full/{z}/{x}/{y}.png', {
	        attribution: 'Tiles courtesy of ' +
                    '<a href="http://openstreetmap.se/">OpenStreetMap Sweden</a>' +
                    ' &mdash; Map data &copy; ' +
                    '<a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(m);
            var overlay = L.featureGroup(features).addTo(m);
            setTimeout(function() {
                m.invalidateSize();
                m.fitBounds(overlay.getBounds());
            }, 100);
        } else {
            div.addClass('noMap');
            div.append('No map');
        }
        return div;
    },

    _makeMarker: function(context, type, json, colorJson, useCustomMarker, label) {
        var lat, lon;
        var obj = json;
        switch (type){
            case 'stop_date_time':
                obj = json.stop_point;
                lat = obj.coord.lat;
                lon = obj.coord.lon;
                break;
            case 'place':
                lat = json[json.embedded_type].coord.lat;
                lon = json[json.embedded_type].coord.lon;
                break;
            default:
                lat = json.coord.lat;
                lon = json.coord.lon;
        }
        var sum = summary.run(context, type, json);
        var t = type === 'place' ? json.embedded_type : type;
        var marker;
        if (! useCustomMarker) {
            marker = L.marker([lat, lon]);
        } else {
            var color = '#000000';
            if (colorJson  && colorJson instanceof Object && colorJson.color) {
                color = '#' + colorJson.color;
            }
            marker = L.circleMarker([lat, lon], {color: color, opacity: 1, fillColor: 'white', fillOpacity: 1});
            marker.setRadius(5);
        }
        if (label) {
            marker.bindLabel(label, {noHide: true, className: 'map-marker-label'});
        }
        return [marker.bindPopup(map._makeLink(context, t, obj, sum)[0])];
    },

    bikeColor: { color: 'CED480' },
    carColor: { color: 'EFBF8F' },
    walkingColor: { color: '89C6E5' },

    _makeString: function(context, type, json, colorJson) {
        if (! ( "geojson" in json) || ! json.geojson.coordinates.length) {
            return [];
        }
        if (! (colorJson instanceof Object) || ! (colorJson.color)) {
            colorJson = { color: '000000' };
        }
        var sum = summary.run(context, type, json);
        return [
            L.geoJson(json.geojson, {
                style: {
                    color: getTextColor(colorJson),
                    weight: 6,
                    opacity: 1
                }
            }),
            L.geoJson(json.geojson, {
                style: {
                    color: "#" + colorJson.color,
                    weight: 5,
                    opacity: 1
                }
            }).bindPopup(sum)
        ];
    },
    _makeStopTimesMarker: function(context, json, color, draw_section_option) {
        var stopTimes = json['stop_date_times'];
        var markers = [];

        if (stopTimes) {
            // when section is PT
            stopTimes.forEach(function(st, i) {
                var label = null;
                if (i === 0 &&
                    map._should_draw_section_start(draw_section_option)) {
                    label = map.STARTTEXT;
                }else if (i === (stopTimes.length -1 ) &&
                          map._should_draw_section_end(draw_section_option)) {
                    label = map.ENDTEXT;
                }
                markers = markers.concat(map._makeMarker(context, 'stop_date_time', st, color, true, label));
            });
        } else {
            // when section is Walking
            var from = json.from;
            var to = json.to;
            if (! from || ! to) { return markers; }
            var label_from = null;
            var label_to = null;
            if (map._should_draw_section_start(draw_section_option)) {
                label_from = map.STARTTEXT;
            }
            if (map._should_draw_section_end(draw_section_option)) {
                label_to = map.ENDTEXT;
            }
            markers = markers.concat(map._makeMarker(context, 'place', from, color, true, label_from))
                             .concat(map._makeMarker(context, 'place', to, color, true, label_to));
        }
        return markers;
    },
    _makePolygon: function(context, type, geoJsonCoords, json, colorJson) {
        var sum = summary.run(context, type, json);
        // TODO use link when navitia has debugged the ticket NAVITIAII-2133
        var link = map._makeLink(context, type, json, sum)[0];
        return [
            L.geoJson(geoJsonCoords, {
                color:  '#555555',
                opacity: 1,
                weight: 0.5,
                fillColor:  '#' + colorJson.color,
                fillOpacity: 0.25
            }).bindPopup(link)
        ];
    },
    _makeLink: function(context, type, obj, name) {
        return context.makeLink(type, obj, name);
    }
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

var modes = {};

modes.makePtPicto = function(json) {
    if ($.isArray(json)) {
        var res = $('<span/>');
        json.forEach(function(elt) {
            res.append(modes.makePtPicto(elt));
        });
        return res;
    }

    if (!(json instanceof Object) || !('id' in json)) {
        return $('<span/>');
    }
    var img = 'Unknown';
    switch (json.id) {
    case 'physical_mode:Air': img = 'Air'; break;
    case 'physical_mode:Bike': img = 'Bike'; break;
    case 'physical_mode:BikeSharingService': img = 'BikeSharingService'; break;
    case 'physical_mode:Car': img = 'Car'; break;
    case 'physical_mode:Coach': img = 'Coach'; break;
    case 'physical_mode:Funicular': img = 'Funicular'; break;
    case 'physical_mode:Metro': img = 'Metro'; break;
    case 'physical_mode:Taxi': img = 'Taxi'; break;
    case 'physical_mode:Tramway': img = 'Tramway'; break;
    case 'physical_mode:Walking': img = 'Walking'; break;

    case 'physical_mode:Bus':
    case 'physical_mode:BusRapidTransit':
    case 'physical_mode:Trolleybus':
        img = 'Bus'; break;

    case 'physical_mode:RapidTransit':
    case 'physical_mode:LocalTrain':
    case 'physical_mode:LongDistanceTrain':
    case 'physical_mode:Train':
        img = 'Train'; break;

    case 'physical_mode:Boat':
    case 'physical_mode:Ferry':
        img = 'Boat'; break;

    case 'physical_mode:Shuttle': // What is? Boat? Bus?
    default:
        break;
    }

    return modes.makeImg(img, json.name);
};

modes.makeImg = function(img, name) {
    var tag = $('<img/>')
        .addClass('mode')
        .attr('src', sprintf('img/modes/%s.svg', img));
    if (name) { tag.attr('alt', name); }
    return tag;
};

modes.makeSnPicto = function(mode) {
    var img = 'Unknown';
    if (mode === 'walking') {
        img = 'Walking';
    } else if (mode === 'bike') {
        img = 'Bike';
    } else if (mode.indexOf('bss') === 0) {
        img = 'BikeSharingService';
    } else if (mode === 'car' || mode === 'park' || mode === 'leave_parking') {
        img = 'Car';
    }
    return modes.makeImg(img, mode);
}

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/* TODO: Complete the jshint*/

function makeDeleteButton() {
    return $('<button/>')
        .addClass('delete')
        .click(function() { $(this).closest('.toDelete').remove(); updateAddPathAC(this); updateUrl(this); })
        .html('<img src="img/delete.svg" class="deleteButton" alt="delete">');
}

function insertPathElt() {
    var key = $('#addPathInput').val();
    $("#addPathElt").before(makeKeyValue(key, '', 'path'));
    autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    $('#addPathInput').val('').change();
    $("#addPathElt").prev().find('input').first().focus();
}

function insertParam() {
    var key = $('#addParamInput').val();
    $('#addParam').before(makeKeyValue(key, '', 'parameters'));
    $('#addParamInput').val('').change();
    $('#addParam').prev().find('input').first().focus();
}

function makeTemplatePath(val, input) {
    var templateFilled = false;
    var isTemplateFilled = function() {
        var curVal = input.val();
        if (! templateFilled && curVal !== val && curVal !== '') {
            input.closest('.inputDiv').removeClass('templateInput');
            templateFilled = true;
        }
        return templateFilled;
    };
    input.closest('.inputDiv').addClass('templateInput');
    input.focus(function() {
        if (! isTemplateFilled()) { this.value = ''; }
    }).blur(function() {
        if (! isTemplateFilled()) { this.value = val; }
    });
}

function updateAddPathAC(val){
    var input = $(val).prev();
    if (! input.hasClass('path')) {
        return;
    }
    if (! $('input path').length) {
        // No more path inputs, we should update autocomplete of add
        autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    }
};

function updateAddParamAC() {
    autocomplete.addKeyAutocomplete($('#addParamInput'), 'paramKey');
}
function makeKeyValue(key, val, cls) {
    var res = $('<div/>')
        .addClass('inputDiv')
        .addClass('toDelete')
        .append(' ');

    res.append($('<span/>').addClass('key').text(key));

    var valueElt = $('<input/>')
         .attr('type', 'text')
         .attr('placeholder', 'type your value here')
        .addClass('value')
        .addClass(cls)
        .val(val);

    autocomplete.valueAutoComplete(valueElt, key);

    valueElt.on('input', function() { updateUrl(this); });
    valueElt.focus(function() { updateUrl(this); });
    res.append(valueElt);
    res.append(makeDeleteButton());

    // valueElt must be attached to res to call this
    if (isTemplate(val)) { makeTemplatePath(val, valueElt); }

    return res;
}

function getFocusedElemValue(elemToTest, focusedElem, noEncoding) {
    var value = $(elemToTest).is('input') ? elemToTest.value : $(elemToTest).text();
    if (! noEncoding) { value = encodeURIComponent(value); }
    if (focusedElem == elemToTest) {
        return sprintf('<span class="focusedParam">%s</span>', value);
    } else {
        return value;
    }
}

function finalUrl(focusedElem) {
    var api = getFocusedElemValue($('#api input.api')[0], focusedElem, true);
    if (api.slice(-1) === "/") { api = api.slice(0, -1); }

    var path = '';
    $('#path .key, #path input.value').each(function(){
        path += '/' + getFocusedElemValue(this, focusedElem);
    });
    var feature = getFocusedElemValue($('#featureInput')[0], focusedElem);

    var parameters = '?';
    $('#parameters .key, #parameters input.value').each(function(){
        parameters += getFocusedElemValue(this, focusedElem);
        if ($(this).hasClass('key')) {
            parameters += '=';
        }
        if ($(this).hasClass('value')) {
            parameters += '&';
        }
    });

    if (focusedElem === undefined) {
        // called without arg, we want pure text
        return api + path + '/' + feature + parameters;
    } else {
        // with arg, we want a rendering thing
        return sprintf('<span class="api">%s</span>' +
                       '<span class="path">%s</span>' +
                       '<span class="feature">/%s</span>' +
                       '<span class="parameters">%s</span>',
                       api, path, feature, parameters);
    }
    return finalUrl;
}

function submit() {
    var token = $('#token input.token').val();
    var f = finalUrl(); // finalUrl can be called without any args
    window.location = sprintf('?request=%s&token=%s', encodeURIComponent(f), encodeURIComponent(token));
}

function updateUrl(focusedElem) {
    var f = finalUrl(focusedElem);
    $('#requestUrl').html(f);
}

function getCoverage() {
    var prevIsCoverage = false;
    var coverage = null;
    var covElt = $("#path .key, #path input.value").each(function() {
        if (prevIsCoverage) {
            coverage = $(this).val();
        }
        prevIsCoverage = $(this).text() == 'coverage';
    });
    return coverage;
}

function parseUrl() {
    var search = new URI(window.location).search(true);
    var request = search['request'];
    if (request === undefined) { return null; }

    var req_uri = new URI(request);
    var api = req_uri.origin();
    var paths = req_uri.path().split('/');
    paths = paths.length == 1 ? [] : paths.slice(1);
    var api_path = [];

    var vxxFound = false;
    paths.forEach(function(r) {
        if (vxxFound) {
            api_path.push(decodeURIComponent(r));
        } else {
            api += '/' + decodeURIComponent(r);
            vxxFound = /^v\d+$/.test(r);
        }
    });
    if (! vxxFound) {
        api = req_uri.origin();
        api_path = paths.map(decodeURIComponent);
        $.notify('Version not found in the URL. Maybe you forgot "/v1" at the end of the API?');
    }

    var params = req_uri.search(true);

    var token = search['token'];
    if (token === undefined) { token = getTokenFromStorage(api); }

    return {
        token: token,
        request: request,
        api: api,
        path: api_path,
        query: params === undefined ? {} : params
    };
}

function setAutocomplete(){
    autocomplete.addKeyAutocomplete($('#featureInput'), 'features');
    autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    autocomplete.addKeyAutocomplete($('#addParamInput'), 'paramKey');
    autocomplete.apiAutocomplete();
}

$(document).ready(function() {
    // Manage add input/button
    $('button.add').prop('disabled', true);
    $('.addInput').on('input change', function() {
        $(this).parent().find('button.add').prop('disabled', this.value.length === 0);
    });
    $(".addInput").keyup(function(event) {
        if (event.keyCode == 13) {
            $(this).parent().find("button.add").click();
        }
    });
    $("#featureInput").focusout(updateAddParamAC);

    var request = parseUrl();

    autocomplete.addKeyAutocomplete($('#featureInput'), 'features');
    autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    autocomplete.addKeyAutocomplete($('#addParamInput'), 'paramKey');
    autocomplete.apiAutocomplete();

    if (request === null) {
        setAutocomplete();
        return;
    }

    if (request.token === undefined) { request.token = ''; }
    $("#token input.token").attr('value', request.token);
    $("#api input.api").attr('value', request.api);

    var prevPathElt = null;
    request.path.forEach(function(r) {
        if (prevPathElt === null) {
            prevPathElt = r;
        } else {
            $("#addPathElt").before(makeKeyValue(prevPathElt, r, 'path'));
            prevPathElt = null;
        }
    });
    if (prevPathElt !== null) {
        $('#featureInput').val(prevPathElt);
    }

    var addParam = $("#addParam");
    for (var key in request.query) {
        var value = request.query[key];
        // a list of params, ex.: forbidded_uris[]
        if (Array.isArray(value)) {
            value.forEach(function(v){
                addParam.before(makeKeyValue(decodeURIComponent(key), decodeURIComponent(v), 'parameters'));
            });
        } else {
            addParam.before(makeKeyValue(decodeURIComponent(key), decodeURIComponent(value), 'parameters'));
        }
    }
    setAutocomplete();
    updateUrl(null);
});

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

function setStatus(xhr, start_time) {
    var status = sprintf('Status: %s (%s)', xhr.statusText, xhr.status);
    if (typeof start_time === 'number') {
        var duration = new Date().getTime() - start_time;
        status += sprintf(', duration of the request: %sms', duration);
    }
    $('#status').text(status);
}

function responseCollectionName(json) {
    var key = null;
    var notCollectionKeys = ['disruptions', 'links', 'feed_publishers', 'exceptions', 'notes', 'warnings'];
    for (var k in json) {
        if ($.isArray(json[k]) &&
            $.inArray(k, notCollectionKeys) === -1) {
            key = k;
        }
    }
    // disruptions may be an object list only if there is no other object list
    if (key === null && 'disruptions' in json) {
        key = 'disruptions';
    }
    return key;
}

function makeObjectButton(name, handle) {
    // TODO call handle on toggle
    return $('<label>')
        .addClass('objectButton')
        .append($('<input type="checkbox">').change(handle))
        .append($('<span>').html(name));
}

function makeObjectButtonHandle(selector, renderHandle) {
    return function() {
        var div = $(this).closest('div.object').children('div.data').children(selector);
        if ($(this).is(':checked')) {
            div.hide();
            div.removeClass('not_filled');
            div.html(renderHandle());
            div.slideDown(600);
        } else {
            div.slideUp(600, function() {
                div.addClass('not_filled');
                div.empty();
            });
        }
    };
}

function render(context, json, type, key, idx) {
    var name = key;
    if (typeof idx === 'number') { name += sprintf('[%s]', idx); }
    name = context.makeLink(key, json, name);

    var head = $('<div class="head">');
    head.append($('<div class="name">').html(name));
    head.append($('<div class="summary">').html(summary.run(context, type, json)));
    var button = $('<div class="button">');
    if (extended.hasExtended(context, type, json)) {
        button.append(makeObjectButton('Ext', makeObjectButtonHandle('div.extended', function() {
                    return extended.run(context, type, json);
                })))
    }
    if (map.hasMap(context, type, json)) {
        button.append(makeObjectButton('Map', makeObjectButtonHandle('div.map', function() {
                    return map.run(context, type, json);
                })))
    }
    button.append(makeObjectButton('{ }', makeObjectButtonHandle('div.code', function() {
        return renderjson(json);
    })));
    head.append(button);

    var data = $('<div class="data">')
        .append($('<div class="extended not_filled">'))
        .append($('<div class="map not_filled">'))
        .append($('<div class="code not_filled">'));

    var result = $('<div class="object">');
    result.append(head);
    result.append(data);
    return result;
}

function Context(data) {
    // the token, used to create links
    var token = URI(window.location).search(true).token;

    // the regex corresponding to the thing that should be replacced
    // in a templated link
    var templateRegex = /\{.*\.id\}/;

    // the link map: type -> template
    this.links = {};
    if (data instanceof Object && 'links' in data && $.isArray(data.links)) {
        var self = this;
        data.links.forEach(function(link) {
            if (! link.templated) { return; }
            if (link.type === 'related') { return; }
            if (! link.href.match(templateRegex)) { return; }
            self.links[getType(link.type)] = link.href;
        });
    }

    this.makeHref = function(href) {
        var res = sprintf('?request=%s', encodeURIComponent(href));
        if (token) {
            res += sprintf('&token=%s', encodeURIComponent(token));
        }
        return res;
    };

    this.makeLink = function(k, obj, name) {
        var key = getType(k);
        if (! (key in this.links) || ! ('id' in obj)) {
            return $('<span/>').html(name);
        }
        var href = this.links[key].replace(templateRegex, obj.id);
        return $('<a>').attr('href', this.makeHref(href)).html(name);
    };

    this.min_duration_color = {};
    if (data instanceof Object && 'isochrones' in data && $.isArray(data.isochrones)) {
        var min_duration = data.isochrones.map(function(isochrone) { return isochrone.min_duration; });
        var max_isochrone = data.isochrones.length;
        var scale = max_isochrone > 1 ? max_isochrone - 1 : 1;
        for (var i = 0; i < max_isochrone; i ++) {
            var ratio = i / scale;
            var r = 255;
            var g = 255;
            if (ratio < 1/2) {
                r = Math.ceil(255 * ratio * 2);
            } else {
                g = Math.ceil(255 * (1 - ratio) * 2);
            }
            var hex = sprintf("%02x%02x%02x", r, g, 0);
            this.min_duration_color[min_duration[i]] = { color: hex };
        }
    }
}

function manage_token (token) {
  return token ? { Authorization: 'Basic ' + btoa(token) } : {};
}

$(document).ready(function() {
    renderjson.set_show_to_level(1);
    renderjson.set_max_string_length(60);
    renderjson.set_sort_objects(true);

    var request = parseUrl();
    if (request === null) {
        $('#status').html('Status: no request');
        return;
    }
    var start_time = new Date().getTime();
    $.ajax({
        headers: manage_token(request.token),
        url: request.request,
        dataType: 'json',
    }).then(
        function(data, status, xhr) {
            setStatus(xhr, start_time);
            $('#data').html(render(new Context(data), data, 'response', 'response'));
            $('#data input').first().click();
            saveToken(request.api, request.token);
            // update the drop list of autocompletion for API
            autocomplete.apiAutocomplete();
        },
        function(xhr, status, error) {
            setStatus(xhr, start_time);
            $('#data').html(render(new Context(xhr.responseJSON), xhr.responseJSON, 'error', 'response'));
            $('#data input').last().click();
            notifyOnError(xhr, 'Response');
        }
    );
});

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

var summary = {};

summary.make = {};

summary.make.response = function(context, json) {
    if (! json) {
        return 'Error: response is not JSon';
    }
    if ('message' in json) {
        return sprintf('Message: %s', htmlEncode(json.message));
    }
    if ('error' in json && json.error && 'message' in json.error) {
        return sprintf('Error: %s', htmlEncode(json.error.message));
    }
    var result = '';
    var key = responseCollectionName(json);
    if (key) {
        result = result + sprintf(' %s %s ', json[key].length, key);
    }
    if ('pagination' in json) {
        var p = json.pagination;
        var first_number = p.start_page * p.items_per_page + 1;
        result = result + sprintf('(%s-%s of %s results)',
            first_number,
            first_number + p.items_on_page - 1,
            p.total_result);
    }
    return result;
};

summary.make.journey = function(context, json) {
    var res = $('<span>').append(summary.formatTime(json.departure_date_time));
    function add(s) {
        res.append(' > ');
        res.append(s);
    }

    if ('sections' in json) {
        var first_section_mode = null;
        var last_section_mode = null;
        json.sections.forEach(function(s) {
            switch (s.type) {
            case 'public_transport':
            case 'on_demand_transport':
                if (! first_section_mode) {
                    first_section_mode = last_section_mode;
                }
                last_section_mode = null;
                break;
            case 'street_network':
                switch (s.mode) {
                case 'bike': last_section_mode = 'bike'; break;
                case 'car': last_section_mode = 'car'; break;
                case 'walking':
                    if (! last_section_mode) { last_section_mode = 'walking'; }
                    break;
                }
                break;
            case 'bss_rent':
            case 'bss_put_back':
                last_section_mode = 'bss';
                break;
            }
        });

        if (first_section_mode) {
            add(modes.makeSnPicto(first_section_mode));
        }
        json.sections.forEach(function(s) {
            if ($.inArray(s.type, ['public_transport', 'on_demand_transport']) === -1) { return; }
            add(summary.makePhysicalModesFromSection(s)
                .append(summary.makeLineCode(s.display_informations)))
        });
        if (last_section_mode) {
            add(modes.makeSnPicto(last_section_mode));
        }
    } else {
        // isochron
        add(summary.run(context, 'place', json.from));
        add(sprintf('%s transfer(s)', json.nb_transfers));
        add(summary.run(context, 'place', json.to));
    }

    add(summary.formatTime(json.arrival_date_time));
    if ('durations' in json) {
        if (json.durations.total) {
            res.append(', duration: ' + durationToString(json.durations.total));
        }
        if (json.durations.walking) {
            res.append(', ');
            res.append(modes.makeSnPicto('walking'));
            res.append(durationToString(json.durations.walking));
        }
    } else {
        res.append(', duration: ' + durationToString(json.duration));
    }
    return res;
};

summary.make.isochrone = function(context, json) {
    var res = $('<span>');
    if ('from' in json) {
      res.append(sprintf('from %s, ', htmlEncode(json.from.name)));
    }
    if ('to' in json) {
      res.append(sprintf('to %s, ', htmlEncode(json.to.name)));
    }
    if ('min_duration' in json && 'max_duration' in json) {
        res.append(sprintf('duration: [%s, %s]',
                          durationToString(json.min_duration),
                          durationToString(json.max_duration)));
    } else {
        res.text('no summary');
    }
    return res;
};

summary.make.links = function(context, json) {
    var res = $('<span>');
    function makeData(link) {
        if (link.templated) {
            return sprintf('{%s}', link.type);
        }
        return link.type;
    }
    if ($.isArray(json)) {
        json.forEach(function(link) {
            res.append(' ')
                .append($('<a>')
                        .attr('href', context.makeHref(link.href))
                        .html(makeData(link)));
        });
    } else {
        res.append('Links is not an array!');
    }
    return res;
};

summary.make.warning = function(context, json) {
    return $('<span>').text(json.message);
}

summary.make.pt_object = summary.make.place = function(context, json) {
    return $('<span>')
        .text(json.embedded_type)
        .append(': ')
        .append(summary.run(context, json.embedded_type, json[json.embedded_type]));
};

summary.make.section = function(context, section) {
    var res = $('<span>');
    var pt = false;

    switch (section.type) {
    case 'street_network': res.append(modes.makeSnPicto(section.mode)); break;
    case 'bss_rent':
        res.append(modes.makeSnPicto('bss')).append(' rent');
        break;
    case 'bss_put_back':
        res.append(modes.makeSnPicto('bss')).append(' put back');
        break;
    case 'leave_parking':
        res.append(modes.makeSnPicto('car')).append(' leave parking');
        break;
    case 'transfer':
        if (section.transfer_type === 'walking') {
            res.append(modes.makeSnPicto('walking'));
        } else {
            res.append(document.createTextNode(section.transfer_type));
        }
        break;
    case 'on_demand_transport':
        res.append(section.type + ' ');
    case 'public_transport':
        pt = true;
        res.append(summary.makeRoutePoint(context, section));
        break;
    default: res.append(section.type); break;
    }

    if ('from' in section) {
        res.append(sprintf(' from %s', htmlEncode(section.from.name)));
    }
    if (pt) {
        res.append(sprintf(' at %s', summary.formatTime(section.departure_date_time)));
    }
    if ('to' in section) {
        res.append(sprintf(' to %s', htmlEncode(section.to.name)));
    }
    if (pt) {
        res.append(sprintf(' at %s', summary.formatTime(section.arrival_date_time)));
    }
    if ('duration' in section) {
        res.append(sprintf(' during %s', durationToString(section.duration)));
    }
    return res;
};

summary.make.region = function(context, region) {
    return region.id + (region.name ? sprintf(' (%s)', region.name) : '');
};

summary.make.line = function(context, line) {
    var code = $('');
    if (line.code) {
        code = $('<span>')
            .addClass('line_code')
            .append(line.code);
        summary.setColors(code, line);
    }
    return $('<span>')
        .append(modes.makePtPicto(line.physical_modes))
        .append(code)
        .append(' ')
        .append(document.createTextNode(line.name));
};

summary.make.stop_date_time = function(context, stop_time) {
    var sum = summary.run(context, 'stop_point', stop_time.stop_point)
    var res = $('<span>').append(summary.formatTime(stop_time.arrival_date_time))
                         .append(' > ')
                         .append(summary.formatTime(stop_time.departure_date_time))
                         .append(' ')
                         .append(sum);
    return res;
};

summary.make.departure = function(context, json) {
    var res = $('<span>');
    res.append(sprintf('%s : ', summary.formatTime(json.stop_date_time.departure_date_time)));
    res.append(summary.makeRoutePoint(context, json));
    return res;
};

summary.make.arrival = function(context, json) {
    var res = $('<span>');
    res.append(sprintf('%s : ', summary.formatTime(json.stop_date_time.arrival_date_time)));
    res.append(summary.makeRoutePoint(context, json));
    return res;
};

summary.make.stop_schedule = function(context, json) {
    return summary.makeRoutePoint(context, json);
};

summary.make.date_time = function(context, json) {
    var res = $('<span>');
    res.append(summary.formatTime(json.date_time));
    res.append(' (' + json.data_freshness + ')');
    return res;
};

summary.make.route_schedule = function(context, json) {
    return summary.makeRoutePoint(context, json);
};

summary.make.physical_mode = function(context, json) {
    return $('<span/>')
        .append(modes.makePtPicto(json))
        .append(document.createTextNode(' ' + json.name));
};

summary.make.connection = function(context, json) {
    return $('<span/>').text(sprintf('%s > %s, duration: %s, display_duration: %s',
                                     json.origin.id,
                                     json.destination.id,
                                     durationToString(json.duration),
                                     durationToString(json.display_duration)));
}

summary.make.tags = function(context, json) {
    return $('<span/>').text(json.join(', '));
};

// add your summary view by addind:
//   summary.make.{type} = function(context, json) { ... }

summary.setColors = function(elt, json) {
    if ('color' in json) {
        elt.css('background-color', '#' + json.color);
        elt.css('color', getTextColor(json));
    }
};

summary.make.contributor = function(context, json) {
    return $('<span/>').text(sprintf('%s (%s)', json.name, json.license));
};

summary.make.dataset = function(context, json) {
    return $('<span/>').text(sprintf('%s (%s - %s): [%s, %s]',
        json.description,
        json.realtime_level,
        json.system,
        summary.formatDatetime(json.start_validation_date),
        summary.formatDatetime(json.end_validation_date)
    ));
};

summary.defaultSummary = function(context, type, json) {
    if (! (json instanceof Object)) { return 'Invalid object'; }

    var res = $('<span/>');
    if ('physical_modes' in json && $.isArray(json.physical_modes)) {
        json.physical_modes.forEach(function(mode) {
            res.append(modes.makePtPicto(mode));
        });
    }
    if ('label' in json) {
        res.append(document.createTextNode(json.label));
    } else if ('name' in json) {
        res.append(document.createTextNode(json.name));
    } else if ('id' in json) {
        res.append(document.createTextNode(json.id));
    } else {
        res.append('no summary');
    }
    return res;
};

summary.formatDatetime = function(datetime) {
    var formated = datetime.replace(/(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})/,
                                    '$1-$2-$3 $4:$5:$6');
    if (formated.slice(-2) === '00') {
        return formated.slice(0, -3);
    } else {
        return formated;
    }
};

summary.formatTime = function(datetime) {
    return summary.formatDatetime(datetime).split(' ')[1];
};

summary.makePhysicalModesFromSection = function(section) {
    if ('links' in section) {
        var pms = section.links
            .map(function(o) {
                if (o.type == 'physical_mode') {
                    return { id: o.id, name: section.display_informations.physical_mode };
                } else {
                    return null;
                }
            });
        return modes.makePtPicto(pms);
    }
};

summary.makeLineCode = function(display_informations) {
    if (! display_informations.code) { return $(''); }
    var elt = $('<span>')
        .addClass('line_code')
        .append(display_informations.code);
    summary.setColors(elt, display_informations);
    return elt;
};

summary.makeRoutePoint = function(context, json) {
    var res = $('<span/>');
    if ('route' in json) {
        res.append(modes.makePtPicto(json.route.physical_modes));
    } else if ('links' in json && 'display_informations' in json) {
        res.append(summary.makePhysicalModesFromSection(json));
    }
    res.append(summary.makeLineCode(json.display_informations));
    res.append(' > ');
    res.append(json.display_informations.direction);
    if (json.stop_point) {
        res.append(' at ');
        res.append(summary.run(context, 'stop_point', json.stop_point));
    }
    return res;
}

summary.run = function(context, type, json) {
    var res;
    try {
        if (type in summary.make) {
            res = summary.make[type](context, json);
        } else {
            res = summary.defaultSummary(context, type, json);
        }
    } catch (e) {
        console.log(sprintf('summary(%s) thows an exception:', type));
        console.log(e);
        res = 'summary error';
    }
    if (res instanceof jQuery) {
        return res.get(0);
    } else if (typeof res === 'string') {
        return $('<span>').text(res).get(0);
    }
    return res;
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/* exported localStorageAvailable apiStoragePrefix saveToken getTokenFromStorage*/
/* TODO: Complete the jshint*/

function localStorageAvailable() {
    try {
	var storage = window.localStorage,
	    x = '__storage_test__';
	storage.setItem(x, x);
	storage.removeItem(x);
	return true;
    }
    catch(e) {
	return false;
    }
}

var apiStoragePrefix = 'navitiaPlayground.';

function saveToken(api, token) {
    if (! localStorageAvailable()) { return; }
    var key = apiStoragePrefix + api
    if (! token && window.localStorage.getItem(key)) { return; }
    window.localStorage.setItem(key, token);
}

function getTokenFromStorage(api) {
    if (! localStorageAvailable()) { return; }
    return window.localStorage.getItem(apiStoragePrefix + api);
}

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/* TODO: Complete the jshint*/

function isPlaceType(key) {
    return $.inArray(key, ['from', 'to']) !== -1;
}

function isDatetimeType(str) {
    return $.inArray(str, ['since', 'until']) !== -1 || str.match(/datetime$/);
}

function htmlEncode(value) {
    return $('<div/>').text(value).html();
}

function durationToString(duration) {
    var res = '';
    var seconds = duration % 60;
    var minutes = Math.floor(duration / 60) % 60;
    var hours = Math.floor(duration / (60 * 60)) % 24;
    var days = Math.floor(duration / (24 * 60 * 60));

    if (days !== 0) { res += sprintf('%sd', days); }
    if (hours !== 0) { res += sprintf('%sh', hours); }
    if (minutes !== 0) { res += sprintf('%smin', minutes); }
    if (seconds !== 0) { res += sprintf('%ss', seconds); }

    if (! res) {
        return '0s';
    } else {
        return res;
    }
}

function isTemplate(str) {
    return str.slice(0, 1) === '{' && str.slice(-1) === '}';
}

function flatMap(array, f) {
    var result = [];

    array.forEach(function(obj, i, array) {
        result = result.concat(f(obj, i, array));
    });
    return result;
}

function notifyOnError(data, typeError) {
    if (data.status === 401) {
        $('#token').addClass('templateInput');
    }
    $.notify(sprintf("%s error: %s", typeError, data.statusText));
}

function getType(key) {
    if (!key || typeof key !== 'string') {
        return null;
    }
    // hardcoded cases:
    switch (key) {
    case 'places_nearby': return 'place';
    case 'addresses': return 'address';
    case 'from': return 'place';
    case 'to': return 'place';
    }
    // generic plural
    if (key.slice(-1) === 's') { return key.slice(0, -1); }

    // just the key
    return key;
}

function getTextColor(json) {
    function _toNum(c, i) { return +('0x' + c.slice(i, i + 2)); }

    if ('text_color' in json) {
        return '#' + json.text_color;
    }
    if ('color' in json) {
        var c = json.color;
        var grey = 0.21 * _toNum(c, 0) + 0.72 * _toNum(c, 2) + 0.07 * _toNum(c, 4);
        if (grey < 128) {
            return 'white';
        }
    }
    return 'black';
}
